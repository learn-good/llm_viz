<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decoder-only transformer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
            width: 400px;
            /* background-color: #2a2a2a; */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 800px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
        }

        #svg {
            cursor: move;
        }


        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #info-container {
            min-height: 350px;
            padding: 10px;
        }

        #info {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 5px;
            font-size: 16px;
            line-height: 1.5;
            height: 800px;
            border-radius: 15px;
            overflow: hidden;
            background-color: #2a2a2a;
        }

        #info .katex {
            font-size: 1.2em;
        }

        .nav-button {
            cursor: pointer;
        }

        .clickable {
            cursor: pointer;
        }

        /* Dark mode specific styles */
        svg {
            background-color: #2a2a2a;
            border-radius: 15px;
            padding: 10px;
            margin: 10px 0 10px 10px;
            border: 1px solid #444;
        }

        .latex-label:hover {
            cursor: default;
        }

        .latex-label[data-link]:hover {
            cursor: pointer;
        }

        text {
            fill: #e0e0e0;
        }
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script> -->
    <!-- for plotting data -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <!-- TODO  -->
            <svg id="svg" width="1200" height="800">
                <g id="content-layer"></g>
                <g id="navigation-layer"></g>
            </svg>
            <!-- <div id="hidden-content" style="display: none;"></div> -->
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>
            </div>

        </div>
    </div>
    <div id="reporting-container">
        <div id="log-container">
        </div>
    </div>

    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // Globals
        let zoom;
        let contentGroup;


        // SVG Navigation
        let currentView = 'root';
        let undoNavigationHistory = [];
        let redoNavigationHistory = [];

        // SVG paths for navigation arrows
        const arrowPaths = {
            up: "M5,20 L15,5 L25,20 Z",
            back: "M20,5 L5,15 L20,25 Z",
            forward: "M10,5 L25,15 L10,25 Z",
            reset: "M15,5 A10,10 0 1,0 15,25 A10,10 0 1,0 15,5 "
            // reset: "M15,5 A10,10 0 1,0 25,15 M25,10 L21,16 M25,10 L29,16"
            // reset: "M5.5,2 A8,8 0 0,1 17,10"

        };

        // Color constants
        const BACKGROUND_COLOR = '#2a2a2a';
        const RECT_FILL_COLOR = '#3a3a3a';
        const RECT_STROKE_COLOR = '#555';
        const TEXT_COLOR = '#e0e0e0';
        const BUTTON_FILL_COLOR = '#3a3a3a';
        const BUTTON_STROKE_COLOR = '#555';
        const BUTTON_ARROW_COLOR = '#e0e0e0';
        const BUTTON_HOVER_FILL_COLOR = '#4a4a4a';
        const BUTTON_HOVER_ARROW_COLOR = '#ffffff';
        const DISABLED_BUTTON_FILL_COLOR = '#2a2a2a';
        const DISABLED_BUTTON_STROKE_COLOR = '#3a3a3a';
        const DISABLED_BUTTON_ARROW_COLOR = '#4a4a4a';
        const LATEX_LINK_HOVER_COLOR = "#00ffff";

        const LATEX_FONT_SIZE = 16;

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Definition
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const svgWidth = 1200;
        const svgHeight = 800;
        const svg = d3.select("#svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .style("background-color", BACKGROUND_COLOR);

        const contentLayer = d3.select("#content-layer");
        const navigationLayer = d3.select("#navigation-layer");
        // const hiddenContent = d3.select("#hidden-content");

        const svgContent = {
            // 'root': [
            //     // 0. Data preparation and tokenization
            //     // 1. x_tokenized
            //     // 2a. Positional Encoding
            //     // 2b. Token Embedding (Tokenizer)
            //     // 3. Dropout
            //     // 4. LayerNorm
            //     // 5. Repeated Self-Attention Blocks
            //     // 6. Feed Forward MLP
            //     // 7. Residual Connections 
            //     // 8. Configurations (n_embd, block_size, activation fn, etc.)
            // ],
            'box1': {
                boxes: [
                ],
                latexLabels: [
                    { x: 150, y: 250, text: '\\mathbf{X}', color: '#ffffff', info: "Input matrix", link: "root" },
                    { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction" }
                ]
            },
            'root': {
                boxes: [
                    { x: 100, y: 100, width: 200, height: 100, text: 'Box1', link: 'box1', info: "Go to Box1" },
                    { x: 400, y: 100, width: 200, height: 100, text: 'Box2', link: 'box2', info: "Go to Box2" }
                ],
                latexLabels: [
                    { x: 150, y: 250, text: '\\mathbf{X}', color: '#ffffff', info: "Input matrix", width: 50, height: 50, link: "root" },
                    // { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction", width: 50, height: 50 }
                    { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction", link: "root" }
                ]
            },
        };
        // END SVG Definition
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Rendering and linking
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // function preRenderContent() {
        //     for (let view in svgContent) {
        //         const group = hiddenContent.append('g')
        //             .attr('id', `content-${view}`)
        //             .attr('class', 'content');

        //         // Render boxes
        //         if (svgContent[view].boxes) {
        //             svgContent[view].boxes.forEach(item => {
        //                 const rect = group.append('rect')
        //                     .attr('x', item.x)
        //                     .attr('y', item.y)
        //                     .attr('width', item.width)
        //                     .attr('height', item.height)
        //                     .attr('fill', RECT_FILL_COLOR)
        //                     .attr('stroke', RECT_STROKE_COLOR);

        //                 group.append('text')
        //                     .attr('x', item.x + item.width / 2)
        //                     .attr('y', item.y + item.height / 2)
        //                     .attr('text-anchor', 'middle')
        //                     .attr('dominant-baseline', 'central')
        //                     .attr('fill', TEXT_COLOR)
        //                     .text(item.text);
        //             });
        //         }

        //         // Render LaTeX labels
        //         if (svgContent[view].latexLabels) {
        //             svgContent[view].latexLabels.forEach(label => {
        //                 group.append(() => createLatexLabel(label.x, label.y, label.text, label.color, label.info));
        //             });
        //         }
        //     }
        // }


        // function showContent(view) {
        //     contentGroup.selectAll('*').remove();
        //     const content = hiddenContent.select(`#content-${view}`).node();
        //     if (content) {
        //         contentGroup.html(content.innerHTML);
        //         attachEventListeners(view);
        //     } else {
        //         logMessage(`No content found for view: ${view}`);
        //     }
        // }

        function drawContent(view) {
            contentGroup.selectAll('*').remove();

            if (svgContent[view]) {
                // Render boxes
                if (svgContent[view].boxes) {
                    svgContent[view].boxes.forEach(item => {
                        const rect = contentGroup.append('rect')
                            .attr('x', item.x)
                            .attr('y', item.y)
                            .attr('width', item.width)
                            .attr('height', item.height)
                            .attr('fill', RECT_FILL_COLOR)
                            .attr('stroke', RECT_STROKE_COLOR);

                        contentGroup.append('text')
                            .attr('x', item.x + item.width / 2)
                            .attr('y', item.y + item.height / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('fill', TEXT_COLOR)
                            .text(item.text);
                    });
                }

                // Render LaTeX labels
                if (svgContent[view].latexLabels) {
                    svgContent[view].latexLabels.forEach(label => {
                        contentGroup.append(() => createLatexLabel(
                            label.x,
                            label.y,
                            label.text,
                            label.color,
                            label.info,
                            label.link,
                            label.width,
                            label.height
                        ));
                    });
                }

                attachEventListeners(view);
            } else {
                logMessage(`No content found for view: ${view}`);
            }
        }



        function attachEventListeners(view) {
            if (svgContent[view].boxes) {
                svgContent[view].boxes.forEach(item => {
                    const rect = contentLayer.select(`rect[x="${item.x}"][y="${item.y}"]`);
                    const text = contentLayer.select(`text[x="${item.x + item.width / 2}"][y="${item.y + item.height / 2}"]`);

                    if (item.link) {
                        rect.classed('clickable', true);
                        text.classed('clickable', true);

                        rect.on('click', () => navigateTo(item.link));
                        text.on('click', () => navigateTo(item.link));
                    }

                    addDefaultEventListeners(rect.node());
                    addDefaultEventListeners(text.node());
                });
            }

            if (svgContent[view].latexLabels) {
                contentLayer.selectAll('.latex-label').each(function () {
                    addDefaultEventListeners(this);
                });
            }

            // Add listeners to navigation buttons
            navigationLayer.selectAll('.nav-button').each(function () {
                addDefaultEventListeners(this);
            });
        }


        function addDefaultEventListeners(element) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', function (event) {
                // showInfo(event);
                clearInfo(event);
            });

            // Keyboard events
            element.addEventListener('focus', showInfo);
            element.addEventListener('blur', clearInfo);
        }

        function setupZoom() {
            zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .on('zoom', zoomed);

            const svg = d3.select("#svg")
                .call(zoom)
                .on("dblclick.zoom", null);

            contentGroup = contentLayer
                .append("g")
                .attr("class", "content-group");

            // Store the initial transform
            zoom.transform(svg, d3.zoomIdentity);
        }

        function zoomed(event) {
            contentGroup.attr('transform', event.transform);
        }

        function resetZoom() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity,
                d3.zoomTransform(svg.node()).invert([svgWidth / 2, svgHeight / 2])
            );
        }
        // END SVG Rendering and linking
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Navigation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNavigation() {
            navigationLayer.selectAll('.nav-button').remove();
            drawArrowButton('back-button', 5, 5, arrowPaths.back, navigateBack, undoNavigationHistory.length > 0);
            drawArrowButton('forward-button', 55, 5, arrowPaths.forward, navigateForward, redoNavigationHistory.length > 0);
            drawArrowButton('reset-button', svgWidth - 45, 5, arrowPaths.reset, resetZoom, true);
        }


        function drawArrowButton(id, x, y, pathD, clickHandler, isEnabled) {
            const group = navigationLayer.append('g')
                .attr('class', 'nav-button')
                .attr('id', id)
                .attr('transform', `translate(${x}, ${y})`)
                .style('cursor', isEnabled ? 'pointer' : 'default');

            // Button background
            group.append('rect')
                .attr('width', 40)
                .attr('height', 40)
                .attr('rx', 5)
                .attr('ry', 5)
                .attr('fill', isEnabled ? BUTTON_FILL_COLOR : DISABLED_BUTTON_FILL_COLOR)
                .attr('stroke', isEnabled ? BUTTON_STROKE_COLOR : DISABLED_BUTTON_STROKE_COLOR);

            // Arrow
            group.append('path')
                .attr('d', pathD)
                .attr('fill', 'none')
                .attr('stroke', isEnabled ? BUTTON_ARROW_COLOR : DISABLED_BUTTON_ARROW_COLOR)
                .attr('stroke-width', 2)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .attr('transform', 'translate(5, 5)');

            if (isEnabled) {
                group.on('click', clickHandler);

                // Hover effect
                group.on('mouseover', function () {
                    d3.select(this).select('rect').attr('fill', BUTTON_HOVER_FILL_COLOR);
                    d3.select(this).select('path').attr('stroke', BUTTON_HOVER_ARROW_COLOR);
                });

                group.on('mouseout', function () {
                    d3.select(this).select('rect').attr('fill', BUTTON_FILL_COLOR);
                    d3.select(this).select('path').attr('stroke', BUTTON_ARROW_COLOR);
                });
            }
        }



        function navigateTo(view) {
            undoNavigationHistory.push(currentView);
            redoNavigationHistory = []; // Clear redo history
            currentView = view;
            updateView();
            resetZoom();
        }

        function navigateBack() {
            if (undoNavigationHistory.length > 0) {
                redoNavigationHistory.push(currentView);
                currentView = undoNavigationHistory.pop();
                updateView();
                resetZoom();
            }
        }

        function navigateForward() {
            if (redoNavigationHistory.length > 0) {
                undoNavigationHistory.push(currentView);
                currentView = redoNavigationHistory.pop();
                updateView();
                resetZoom();
            }
        }

        // function updateView() {
        //     drawNavigation();
        //     showContent(currentView);
        // }
        function updateView() {
            drawNavigation();
            drawContent(currentView);
        }

        // For debugging
        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        // END SVG Navigation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // LaTeX labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function createLatexLabel(x, y, text, color, labelInfo, link, width = 250, height = 40) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - (width / 2));
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', width);
            foreignObject.setAttribute('height', height);
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;
            foreignObject.dataset.info = labelInfo;

            if (link) {
                foreignObject.dataset.link = link;
                foreignObject.style.cursor = 'pointer';
            }

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: true
            });

            foreignObject.appendChild(div);
            foreignObject.addEventListener('mouseover', showInfo);
            foreignObject.addEventListener('mouseout', clearInfo);
            foreignObject.addEventListener('click', handleLatexClick);

            return foreignObject;
        }

        function handleLatexClick(event) {
            const target = event.currentTarget;
            const link = target.dataset.link;
            if (link) {
                navigateTo(link);
            }
        }
        // END LaTeX labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function showInfo(event) {
            const target = event.currentTarget;
            let content = '';
            // logMessage(target.classList)
            // logMessage(target.classList.contains('latex-label'))

            if (target.classList.contains('nav-button')) {
                if (target.id === 'back-button') {
                    content = "Navigate back to the previous view.";
                } else if (target.id === 'forward-button') {
                    content = "Navigate forward to the next view.";
                } else if (target.id === 'reset-button') {
                    content = "Reset zoom and pan to the initial position.";
                }
            } else if (target.classList.contains('latex-label')) {
                content = target.dataset.info;
            } else if (target.tagName === 'rect' || target.tagName === 'text') {
                const item = svgContent[currentView].boxes.find(i =>
                    i.x == target.getAttribute('x') ||
                    (target.tagName === 'text' && i.x + i.width / 2 == target.getAttribute('x'))
                );
                if (item && item.info) {
                    content = item.info;
                }
            }
            renderInfoContent(document.getElementById('info'), content);
        }



        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }

        function clearInfo(event) {
            const defaultStr = "";
            document.getElementById('info').textContent = defaultStr;
        }
        // END Display detailed info top-right
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Main
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        window.onload = function () {
            setupZoom();
            updateView();
        }
    </script>
</body>