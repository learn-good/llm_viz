<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Decoder-only transformer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1e1e1e;
            color: #e0e0e0;
        }

        #reporting-container {
            font-size: 16px;
            line-height: 1.5;
            font-family: 'Courier New', Courier, monospace;
            padding: 20px;
            width: 400px;
            /* background-color: #2a2a2a; */
        }

        #main-container {
            display: flex;
            width: 100%;
            height: 800px;
        }

        #svg-container {
            flex: 0 0 1200px;
            z-index: 10;
        }

        #svg {
            cursor: move;
        }


        #right-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 840px;
        }

        .container {
            display: flex;
            justify-content: center;
        }

        #info-container {
            flex: 4;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        #info {
            /* margin-bottom: 20px; */
            /* height: 550px; */
            flex: 1;
            padding: 10px;
            border: 1px solid #444;
            font-size: 16px;
            line-height: 1.5;
            border-radius: 15px;
            overflow: hidden;
            background-color: #2a2a2a;
        }

        #info .katex {
            font-size: 1.2em;
        }

        .nav-button {
            cursor: pointer;
        }

        .clickable {
            cursor: pointer;
        }

        /* Dark mode specific styles */
        svg {
            background-color: #2a2a2a;
            border-radius: 15px;
            padding: 10px;
            margin: 10px 0 10px 10px;
            border: 1px solid #444;
        }

        .latex-label:hover {
            cursor: default;
        }

        .latex-label[data-link]:hover {
            cursor: pointer;
        }

        /* References */
        #references-container {
            /* height: 250px; */
            flex: 1;
            display: flex;
            flex-direction: row;
            padding: 0px 10px 10px 10px;
        }

        #references {
            /* height: 220px; */
            flex: 1;
            padding: 10px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 15px;
        }

        #references-container h3 {
            margin-top: 0;
            color: #b4b4b4;
        }

        #references-list {
            height: 150px;
            list-style-type: none;
            padding: 5px;
            overflow-y: auto;
            margin: 0;
        }

        #references-list li {
            margin-bottom: 10px;
        }

        #references-list a {
            color: #b4b4b4;
            text-decoration: none;
        }

        #references-list a:hover {
            color: #00ffff;
            text-decoration: underline;
        }


        /* text {
            fill: #e0e0e0;
        } */
    </style>
    <!-- for LaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <!-- for anim -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script> -->
    <!-- for plotting data -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        HTML
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <div id="main-container">
        <div id="svg-container">
            <svg id="svg" width="1200" height="800">
                <g id="content-layer"></g>
                <g id="navigation-layer"></g>
            </svg>
        </div>
        <div id="right-container">
            <div id="info-container">
                <div id="info"></div>

            </div>
            <div id="references-container">
                <div id="references">
                    <h3>References</h3>
                    <ul id="references-list"></ul>
                </div>
            </div>
        </div>
    </div>
    <div id="reporting-container">
        <div id="log-container">
        </div>
    </div>

    <!--=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        Javascript
     -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-->
    <script>
        // Globals
        let zoom;
        let contentGroup;


        // SVG Navigation
        let currentView = 'root';
        let undoNavigationHistory = [];
        let redoNavigationHistory = [];

        // SVG paths for navigation arrows
        const arrowPaths = {
            up: "M5,20 L15,5 L25,20 Z",
            back: "M20,5 L5,15 L20,25 Z",
            forward: "M10,5 L25,15 L10,25 Z",
            reset: "M15,5 A10,10 0 1,0 15,25 A10,10 0 1,0 15,5 "
        };
        const positionalEncodingPath = "M15,5 A10,10 0 1,0 15,25 A10,10 0 1,0 15,5 M5,15 Q10,10 15,15 Q20,20 25,15";

        // Color constants
        const BACKGROUND_COLOR = '#2a2a2a';
        const RECT_FILL_COLOR = '#3a3a3a';
        const RECT_STROKE_COLOR = '#555';
        const TEXT_COLOR = '#e0e0e0';
        const BUTTON_FILL_COLOR = '#3a3a3a';
        const BUTTON_STROKE_COLOR = '#555';
        const BUTTON_ARROW_COLOR = '#e0e0e0';
        const BUTTON_HOVER_FILL_COLOR = '#4a4a4a';
        const BUTTON_HOVER_ARROW_COLOR = '#ffffff';
        const DISABLED_BUTTON_FILL_COLOR = '#2a2a2a';
        const DISABLED_BUTTON_STROKE_COLOR = '#3a3a3a';
        const DISABLED_BUTTON_ARROW_COLOR = '#4a4a4a';
        const LATEX_LINK_HOVER_COLOR = "#00ffff";
        const LINK_COLOR = '#00ffff';


        const LATEX_FONT_SIZE = 16;

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Definition
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        const svgWidth = 1200;
        const svgHeight = 800;
        const svg = d3.select("#svg")
            .attr("width", svgWidth)
            .attr("height", svgHeight)
            .style("background-color", BACKGROUND_COLOR);

        const contentLayer = d3.select("#content-layer");
        const navigationLayer = d3.select("#navigation-layer");
        // const hiddenContent = d3.select("#hidden-content");

        const svgContent = {
            // 'root': [
            //     // 0. Data preparation and tokenization
            //     // 1. x_tokenized
            //     // 2a. Positional Encoding
            //     // 2b. Token Embedding (Tokenizer)
            //     // 3. Dropout
            //     // 4. LayerNorm
            //     // 5. Repeated Self-Attention Blocks
            //     // 6. Feed Forward MLP
            //     // 7. Residual Connections 
            //     // 8. Configurations (n_embd, block_size, activation fn, etc.)
            // ],
            'box1': {
                boxes: [
                ],
                latexLabels: [
                    { x: 150, y: 250, text: 'X', color: '#ffffff', info: "Input matrix", link: "root" },
                    { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction" }
                ]
            },
            'root': {
                boxes: [
                    { x: 100, y: 100, width: 200, height: 100, text: 'Box1', link: 'box1', info: "Go to Box1" },
                    { x: 400, y: 100, width: 200, height: 100, text: '', link: 'box2', info: "Go to Box2", opacity: 0.5 },
                    // { x: 400, y: 105, width: 205, height: 100, text: 'Box2', link: 'box2', info: "Go to Box2", opacity: 1 }
                ],
                latexLabels: [
                    { x: 150, y: 250, text: 'X', color: '#ffffff', info: "Input matrix", width: 50, height: 50, link: 'box1' },
                    // { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction", width: 50, height: 50 }
                    { x: 450, y: 250, text: '\\hat{y}', color: '#ffffff', info: "Output prediction", link: 'box1' }
                ],
                textLabels: [
                    { x: 350, y: 130, text: 'feedforward', color: '#ffffff', info: "Feedforward connection", link: 'box1' }
                ],
                arrows: [
                    { start: { x: 300, y: 150 }, end: { x: 400, y: 150 }, color: '#ffffff', info: "Connection from Box1 to Box2", link: 'box1' }
                ],

                paths: [
                    { x: 700, y: 100, width: 100, height: 100, pathD: positionalEncodingPath, color: '#ffffff', info: "Positional Encoding", link: 'box1' }
                ],

                // References
                references: [
                    {
                        title: "Attention Is All You Need",
                        // authors: "A. Vaswani, N. Shazeer, N. Parmar, J. Uszkoreit, L. Jones, A. N. Gomez, L. Kaiser, I. Polosukhin",
                        authors: [
                            "Ashish Vaswani",
                            "Noam Shazeer",
                            "Niki Parmari",
                            "Jakob Uszkoreit",
                            "Llion Jones",
                            "Aidan N. Gomez",
                            "Lukasz Kaiser",
                            "Illia Polosukhin",
                        ],
                        link: "https://arxiv.org/abs/1706.03762",
                        info: "The original paper introducing the Transformer architecture.",
                        refType: "arxiv"
                    },
                    {
                        title: "nanoGPT",
                        // authors: "Andrej Karpathy",
                        authors: ["Andrej Karpathy"],
                        link: "https://github.com/karpathy/nanoGPT/blob/master/model.py",
                        info: "A minimal implementation of GPT in PyTorch.",
                        refType: "Github"
                    },
                    {
                        title: "\"Let's build GPT: from scratch, in code, spelled out\"",
                        // authors: "Andrej Karpathy",
                        authors: ["Andrej Karpathy"],
                        link: "https://www.youtube.com/watch?v=kCc8FmEb1nY",
                        info: "A detailed video tutorial on building a GPT model from scratch.",
                        refType: "YouTube"
                    }
                ]

            },
        };
        // END SVG Definition
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Rendering and Event Handling
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawContent(view) {
            contentGroup.selectAll('*').remove();

            if (svgContent[view]) {
                // Render boxes
                if (svgContent[view].boxes) {
                    svgContent[view].boxes.forEach(item => {
                        const rect = contentGroup.append('rect')
                            .attr('x', item.x)
                            .attr('y', item.y)
                            .attr('width', item.width)
                            .attr('height', item.height)
                            .attr('fill', RECT_FILL_COLOR)
                            .attr('stroke', RECT_STROKE_COLOR)
                            .attr('opacity', item.opacity !== undefined ? item.opacity : 1);

                        contentGroup.append('text')
                            .attr('x', item.x + item.width / 2)
                            .attr('y', item.y + item.height / 2)
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'central')
                            .attr('fill', TEXT_COLOR)
                            .attr('opacity', item.opacity !== undefined ? item.opacity : 1)
                            .text(item.text);
                    });
                }

                // Render directed arrow connections
                if (svgContent[view].arrows) {
                    svgContent[view].arrows.forEach(arrow => {
                        const arrowElement = drawArrow(arrow.start, arrow.end, arrow.color);
                        arrowElement.attr('data-info', arrow.info)
                            .attr('data-link', arrow.link);
                    });
                }


                // Render custom paths
                if (svgContent[view].paths) {
                    svgContent[view].paths.forEach(path => {
                        contentGroup.append('path')
                            .attr('d', path.pathD)
                            .attr('transform', `translate(${path.x}, ${path.y}) scale(${path.width / 30}, ${path.height / 30})`)
                            .attr('fill', 'none')
                            .attr('stroke', path.color)
                            .attr('stroke-width', 2)
                            .attr('class', 'custom-path')
                            .attr('data-info', path.info)
                            .attr('data-link', path.link)
                    });
                }

                // Render LaTeX labels
                if (svgContent[view].latexLabels) {
                    svgContent[view].latexLabels.forEach(label => {
                        contentGroup.append(() => createLatexLabel(
                            label.x,
                            label.y,
                            label.text,
                            label.color,
                            label.info,
                            label.link,
                            label.width,
                            label.height
                        ));
                    });
                }

                // Render text labels
                if (svgContent[view].textLabels) {
                    svgContent[view].textLabels.forEach(label => {
                        contentGroup.append(() => createTextLabel(
                            label.x,
                            label.y,
                            label.text,
                            label.color,
                            label.info,
                            label.link
                        ));
                    });
                }

                attachEventListenersForView(view);
            } else {
                logMessage(`No content found for view: ${view}`);
            }
        }


        function attachEventListenersForView(view) {
            // Add listeners to boxes
            if (svgContent[view].boxes) {
                svgContent[view].boxes.forEach(item => {
                    const rect = contentLayer.select(`rect[x="${item.x}"][y="${item.y}"]`);
                    const text = contentLayer.select(`text[x="${item.x + item.width / 2}"][y="${item.y + item.height / 2}"]`);

                    addDefaultEventListeners(rect.node(), item.link);
                    addDefaultEventListeners(text.node(), item.link);

                    if (item.link) {
                        const originalRectStroke = rect.attr('stroke');
                        const originalTextFill = text.attr('fill');

                        rect.on('mouseover', function () { rect.attr('stroke', LINK_COLOR); })
                            .on('mouseout', function () { rect.attr('stroke', originalRectStroke); });

                        text.on('mouseover', function () { rect.attr('stroke', LINK_COLOR); })
                            .on('mouseout', function () { rect.attr('stroke', originalTextFill); });
                    }
                });
            }

            // Add listeners to latex labels
            if (svgContent[view].latexLabels) {
                contentLayer.selectAll('.latex-label').each(function () {
                    const label = d3.select(this);
                    const link = label.attr('data-link');
                    addDefaultEventListeners(this, link);
                    if (link) {
                        const originalColor = label.select('div').style('color');
                        label.on('mouseover', function () { label.select('div').style('color', LINK_COLOR); })
                            .on('mouseout', function () { label.select('div').style('color', originalColor); });
                    }
                });
            }

            // Add listeners to text labels
            if (svgContent[view].textLabels) {
                contentLayer.selectAll('.text-label').each(function () {
                    const label = d3.select(this);
                    const link = label.attr('data-link');
                    addDefaultEventListeners(this, link);
                    if (link) {
                        const originalFill = label.attr('fill');
                        label.on('mouseover', function () {
                            label.attr('fill', LINK_COLOR);
                            showInfo({ currentTarget: this });
                        })
                            .on('mouseout', function () {
                                label.attr('fill', originalFill);
                                clearInfo();
                            })
                    }
                });
            }

            // Add listeners to arrows
            if (svgContent[view].arrows) {
                contentLayer.selectAll('.arrow').each(function () {
                    const arrow = d3.select(this);
                    const link = arrow.attr('data-link');
                    addDefaultEventListeners(arrow.node(), link);
                    if (link) {
                        const originalColor = arrow.attr('stroke');
                        arrow.on('mouseover', function () {
                            arrow.attr('stroke', LINK_COLOR).attr('fill', LINK_COLOR);
                        })
                            .on('mouseout', function () {
                                arrow.attr('stroke', originalColor).attr('fill', originalColor);
                            });
                    }
                });
            }

            // Add listeners to custom paths
            if (svgContent[view].paths) {
                contentLayer.selectAll('.custom-path').each(function () {
                    const path = d3.select(this);
                    const link = path.attr('data-link');
                    addDefaultEventListeners(path.node(), link);
                    if (link) {
                        const originalStroke = path.attr('stroke');
                        path.on('mouseover', function () { path.attr('stroke', LINK_COLOR); })
                            .on('mouseout', function () { path.attr('stroke', originalStroke); });
                    }
                });
            }

            // Add listeners to navigation buttons
            navigationLayer.selectAll('.nav-button').each(function () {
                addDefaultEventListeners(this);
            });
        }


        function addDefaultEventListeners(element, link) {
            element.addEventListener('mouseover', showInfo);
            element.addEventListener('mouseout', clearInfo);
            element.addEventListener('click', function (event) {
                if (link) {
                    navigateTo(link);
                }
                clearInfo(event);
            });

            // Keyboard events
            element.addEventListener('focus', showInfo);
            element.addEventListener('blur', clearInfo);

            // Update cursor style
            element.style.cursor = link ? 'pointer' : 'default';
        }


        function drawArrow(start, end, color) {
            const arrowSize = 10;
            const angle = Math.atan2(end.y - start.y, end.x - start.x);

            // Calculate the position of the arrowhead
            const arrowX = end.x - arrowSize * Math.cos(angle);
            const arrowY = end.y - arrowSize * Math.sin(angle);

            // Create a group for the arrow
            const arrowGroup = contentGroup.append('g')
                .attr('class', 'arrow')
                .attr('stroke', color)
                .attr('fill', color);

            // Draw the line
            arrowGroup.append('line')
                .attr('x1', start.x)
                .attr('y1', start.y)
                .attr('x2', end.x)
                .attr('y2', end.y)
                .attr('stroke-width', 2);

            // Draw the arrowhead
            arrowGroup.append('path')
                .attr('d', `M${end.x},${end.y} L${arrowX - arrowSize * Math.cos(angle - Math.PI / 6)},${arrowY - arrowSize * Math.sin(angle - Math.PI / 6)} L${arrowX - arrowSize * Math.cos(angle + Math.PI / 6)},${arrowY - arrowSize * Math.sin(angle + Math.PI / 6)} Z`);

            return arrowGroup;
        }

        // END SVG Rendering and Event Handling
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Zoom
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function setupZoom() {
            zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .on('zoom', zoomed);

            const svg = d3.select("#svg")
                .call(zoom)
                .on("dblclick.zoom", null);

            contentGroup = contentLayer
                .append("g")
                .attr("class", "content-group");

            // Store the initial transform
            zoom.transform(svg, d3.zoomIdentity);
        }

        function zoomed(event) {
            contentGroup.attr('transform', event.transform);
        }

        function resetZoom() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity,
                d3.zoomTransform(svg.node()).invert([svgWidth / 2, svgHeight / 2])
            );
        }
        // END SVG Zoom
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // SVG Navigation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function drawNavigation() {
            navigationLayer.selectAll('.nav-button').remove();
            drawArrowButton('back-button', 5, 5, arrowPaths.back, navigateBack, undoNavigationHistory.length > 0);
            drawArrowButton('forward-button', 55, 5, arrowPaths.forward, navigateForward, redoNavigationHistory.length > 0);
            drawArrowButton('reset-button', svgWidth - 45, 5, arrowPaths.reset, resetZoom, true);
        }


        function drawArrowButton(id, x, y, pathD, clickHandler, isEnabled) {
            const group = navigationLayer.append('g')
                .attr('class', 'nav-button')
                .attr('id', id)
                .attr('transform', `translate(${x}, ${y})`)
                .style('cursor', isEnabled ? 'pointer' : 'default');

            // Button background
            group.append('rect')
                .attr('width', 40)
                .attr('height', 40)
                .attr('rx', 5)
                .attr('ry', 5)
                .attr('fill', isEnabled ? BUTTON_FILL_COLOR : DISABLED_BUTTON_FILL_COLOR)
                .attr('stroke', isEnabled ? BUTTON_STROKE_COLOR : DISABLED_BUTTON_STROKE_COLOR);

            // Arrow
            group.append('path')
                .attr('d', pathD)
                .attr('fill', 'none')
                .attr('stroke', isEnabled ? BUTTON_ARROW_COLOR : DISABLED_BUTTON_ARROW_COLOR)
                .attr('stroke-width', 2)
                .attr('stroke-linecap', 'round')
                .attr('stroke-linejoin', 'round')
                .attr('transform', 'translate(5, 5)');

            if (isEnabled) {
                group.on('click', clickHandler);

                // Hover effect
                group.on('mouseover', function () {
                    d3.select(this).select('rect').attr('fill', BUTTON_HOVER_FILL_COLOR);
                    d3.select(this).select('path').attr('stroke', BUTTON_HOVER_ARROW_COLOR);
                });

                group.on('mouseout', function () {
                    d3.select(this).select('rect').attr('fill', BUTTON_FILL_COLOR);
                    d3.select(this).select('path').attr('stroke', BUTTON_ARROW_COLOR);
                });
            }
        }


        function navigateTo(view) {
            if (currentView == view) {
                logMessage("repeat navigateTo. exiting");
                return;
            }
            undoNavigationHistory.push(currentView);
            redoNavigationHistory = []; // Clear redo history
            currentView = view;
            updateView();
            resetZoom();
        }

        function navigateBack() {
            if (undoNavigationHistory.length > 0) {
                redoNavigationHistory.push(currentView);
                currentView = undoNavigationHistory.pop();
                updateView();
                resetZoom();
            }
        }

        function navigateForward() {
            if (redoNavigationHistory.length > 0) {
                undoNavigationHistory.push(currentView);
                currentView = redoNavigationHistory.pop();
                updateView();
                resetZoom();
            }
        }

        function updateView() {
            drawNavigation();
            drawContent(currentView);
            renderReferences(currentView);
        }
        // END SVG Navigation
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // LaTeX and plaintext labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function createLatexLabel(x, y, text, color, labelInfo, link, width = 250, height = 40) {
            const foreignObject = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
            foreignObject.setAttribute('x', x - (width / 2));
            foreignObject.setAttribute('y', y - 20);
            foreignObject.setAttribute('width', width);
            foreignObject.setAttribute('height', height);
            foreignObject.classList.add('latex-label');
            foreignObject.dataset.latex = text;
            foreignObject.dataset.info = labelInfo;

            if (link) {
                foreignObject.dataset.link = link;
                // foreignObject.style.cursor = 'pointer';
            }

            const div = document.createElement('div');
            div.style.fontSize = LATEX_FONT_SIZE + 'px';
            div.style.color = color;
            div.style.display = 'flex';
            div.style.justifyContent = 'center';
            div.style.alignItems = 'center';
            div.style.height = '100%';

            katex.render(text, div, {
                throwOnError: true
            });

            foreignObject.appendChild(div);

            return foreignObject;
        }


        function createTextLabel(x, y, text, color, labelInfo, link) {
            const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            textElement.setAttribute('x', x);
            textElement.setAttribute('y', y);
            textElement.setAttribute('fill', color);
            textElement.textContent = text;
            textElement.classList.add('text-label');
            textElement.dataset.info = labelInfo;
            // textElement.setAttribute('data-info', labelInfo);
            if (link) {
                textElement.dataset.link = link;
                // textElement.setAttribute('data-link', link);
            }
            return textElement;
        }
        // END LaTeX and plaintext labels
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Display detailed info top-right
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        function showInfo(event) {
            const target = event.currentTarget;
            let content = '';

            if (target.tagName === 'A' && target.parentElement.parentElement.id === 'references-list') {
                const ref = svgContent[currentView].references.find(r => r.title === target.textContent);
                if (ref) {
                    content = formatReferenceInfo(ref);
                }
            } else if (target.classList.contains('custom-path')) {
                content = target.getAttribute('data-info') || "Custom path";
            } else if (target.classList.contains('arrow')) {
                content = target.getAttribute('data-info') || "Arrow connection";
            } else if (target.classList.contains('nav-button')) {
                if (target.id === 'back-button') {
                    content = "Navigate back to the previous view.";
                } else if (target.id === 'forward-button') {
                    content = "Navigate forward to the next view.";
                } else if (target.id === 'reset-button') {
                    content = "Reset zoom and pan to the initial position.";
                }
            } else if (target.classList.contains('latex-label')) {
                // content = target.dataset.info;
                content = target.getAttribute('data-info');
            } else if (target.classList.contains('text-label')) {
                content = target.getAttribute('data-info');
            } else if (target.tagName === 'rect' || target.tagName === 'text') {
                const item = svgContent[currentView].boxes.find(i =>
                    i.x == target.getAttribute('x') ||
                    (target.tagName === 'text' && i.x + i.width / 2 == target.getAttribute('x'))
                );
                if (item && item.info) {
                    content = item.info;
                }
            }
            renderInfoContent(document.getElementById('info'), content);
        }


        function renderInfoContent(element, content) {
            element.innerHTML = '';
            let currentIndex = 0;

            while (currentIndex < content.length) {
                if (content.startsWith('$$', currentIndex)) {
                    // LaTeX content
                    const endIndex = content.indexOf('$$', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed LaTeX at position', currentIndex);
                        break;
                    }
                    const latexContent = content.slice(currentIndex + 2, endIndex);
                    const span = document.createElement('span');
                    katex.render(latexContent, span, {
                        throwOnError: false,
                        displayMode: false
                    });
                    element.appendChild(span);
                    currentIndex = endIndex + 2;
                } else if (content.startsWith('**', currentIndex)) {
                    // Bold content
                    const endIndex = content.indexOf('**', currentIndex + 2);
                    if (endIndex === -1) {
                        console.error('Unclosed bold at position', currentIndex);
                        break;
                    }
                    const boldContent = content.slice(currentIndex + 2, endIndex);
                    const strong = document.createElement('strong');
                    strong.textContent = boldContent;
                    element.appendChild(strong);
                    currentIndex = endIndex + 2;
                } else {
                    // Plain text
                    const nextSpecialChar = Math.min(
                        content.indexOf('$$', currentIndex) === -1 ? Infinity : content.indexOf('$$', currentIndex),
                        content.indexOf('**', currentIndex) === -1 ? Infinity : content.indexOf('**', currentIndex)
                    );
                    const textContent = content.slice(currentIndex, nextSpecialChar === Infinity ? undefined : nextSpecialChar);
                    const lines = textContent.split('\n');
                    lines.forEach((line, index) => {
                        element.appendChild(document.createTextNode(line));
                        if (index < lines.length - 1) {
                            element.appendChild(document.createElement('br'));
                        }
                    });
                    currentIndex = nextSpecialChar === Infinity ? content.length : nextSpecialChar;
                }
            }
        }

        function clearInfo(event) {
            const defaultStr = "";
            document.getElementById('info').textContent = defaultStr;
        }

        function formatReferenceInfo(ref) {
            let content = ref.info + '\n\n';
            content += `Link type: ${ref.refType}\n\n`;
            content += 'Authors:\n';
            ref.authors.forEach(author => {
                content += `• ${author}\n`;
            });
            return content;
        }
        // END Display detailed info top-right
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

        // Display references bot right
        function renderReferences(view) {
            const referencesList = document.getElementById('references-list');
            referencesList.innerHTML = '';

            if (svgContent[view] && svgContent[view].references) {
                svgContent[view].references.forEach(ref => {
                    const li = document.createElement('li');
                    const a = document.createElement('a');
                    a.href = ref.link;
                    a.target = "_blank";
                    a.textContent = ref.title;
                    a.addEventListener('mouseover', showInfo);
                    a.addEventListener('mouseout', clearInfo);
                    li.appendChild(a);
                    referencesList.appendChild(li);
                });
            }
        }

        // For debugging or general message to user
        function logMessage(message) {
            const logContainer = document.getElementById('log-container');
            logContainer.innerHTML += `<p>${message}</p>`;
            logContainer.scrollTop = logContainer.scrollHeight;
        }

        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        // Main
        //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
        window.onload = function () {
            setupZoom();
            updateView();
        }
    </script>
</body>